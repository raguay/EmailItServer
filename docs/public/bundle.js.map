{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/internal/index.mjs","../src/Main.svexy","../src/MainWindows.svexy","../src/MainMenu.svexy","../src/ScriptEditor.svexy","../src/RegularExpressionEditor.svexy","../src/FeaturesStillComming.svexy","../src/FilesUsed.svexy","../src/TodoList.svexy","../src/Preferences.svexy","../src/Templater.svexy","../src/Alfred.svexy","../src/Dropzone.svexy","../src/KeyboardMaestro.svexy","../src/LaunchBar.svexy","../src/PopClip.svexy","../src/QueryUser.svexy","../src/Modules.svexy","../src/CommandConsole.svexy","../src/NodeRed.svexy","../src/API.svexy","../src/Documentation.svelte","../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { stylesheet } = info;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            info.rules = {};\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.49.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        throw new Error(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","<script>\n\tvar numMods = 'two'\n\tvar numScripts = 32\n</script>\n\n# About ScriptPad\n\n**ScriptPad** is a program for keeping track of nine notes in your menubar,\nediting them with regular expressions, and executing scripts on the \nhighlighted text or the full note. It currently comes with { numScripts } \npredefined scripts. You can create and save your own scripts and \nregular expressions as well.\n\nYou can also see your [NotePlan](https://noteplan.co/) todo list and any \n[TaskPaper](https://www.taskpaper.com/) todo list in the Todo section \n(the clipboard icon on the right). Not only can you view the todo lists,\nyou can add to them, check items off the list, and delete them. Completed\nitems are automatically moved to the bottom for easier viewing of the \nactive items.\n\nYou can also use templates to populate a notepad, modify it, then copy \npaste it to other programs. You can define your own templates and make\nuse of various macros. You can even write your own macros to the template\nsystem.\n\nBy clicking on the hamburger menu to the lower left, you can see the\nmain menu. The main menu allows you to open each of the sections of\nScriptPad. It allso gives access to the help section you are reading now.\nThere are also several launchers to install various helper extensions \nfor [Alfred](https://www.alfredapp.com/),\n[LaunchBar](https://obdev.at/products/launchbar/index.html), \n[PopClip](https://pilotmoon.com/popclip/), [Dropzone 3](https://aptonic.com/),\nand [Keyboard Maestro](https://www.keyboardmaestro.com/main/) to automate\nworking with **ScriptPad**. These scripts allow you to run any functionality\nof ScriptPad in other applications. For instance, you can highlight some \ntext and apply a script to it. Or, you can populate any text processor\nfrom a template that you have designed.\n\nScriptPad also has a module system where you can run modules that have\nbeen created or your own designs. There are currently { numMods } modules with\nmany more to come.\n\nI'm also working on giving ScriptPad the ability to run external scripts\nin it's own environment, a command console to run scripts on files, and\nmany more ideals. If you have any suggestions, please let me know.\n\nThank you for using this product.\n","# Main Window\n\n![The Main Window](http://localhost:9978/imgs/MainWindow.jpg)\n\nWhen you run the ScriptPad program, you will see the above picture. \nScriptPad has nine circles at the bottom. Each one is a different notepad to use. \nThe notepad currently in use has a larger circle than the ones that are inactive.\nIn the above picture, the third notepad is currently active. You can switch\nnotepads by clicking on the circles or by the keyboard shortcut `<ctrl> 1` for\nthe first notepad, `<ctrl> 2` for the second, and so on.\n\nThe hamburger menu on the far left opens the main menu. The clipboard icon on the\nfar right opens the Todo List.\n\nEach notepad can be edited with all edits saved to your hard drive in a special\nlocation. The information is in a plaintext format. Therefore, it is recommended\nto not put any sensitive data into it.\n\nBy pressing `<ctrl> m`, you will open the scripts menu. This gives a list of\nbuilt-in and user defined scripts to execute on the text in the current notepad.\nIf you have some text highlighted, just that text will be sent to the script.\nIf nothing is highlighted, than the whole note will be sent to the script. \n\nYou can access the script editor by pressing `<ctrl> e`. The script editor allows\nyou to create and edit your own scripts.\n\nBy pressing `<ctrl> r`, you will open the regular expressions editor. With this\neditor, you can create, save, and edit the current notepad by using a regular\nexpression.\n\nBy pressing `<ctrl> p` you will be given a list of templates to insert into the \nnote and the current cursor location. You can edit/create/delete templates from\nthe template editor using either the item in the main menu or by pressing \n`<ctrl> t`.\n\nBy pressing `<ctrl> o` you will open the command console. This part is still\nunder construction.\n\n","# Main Menu\n\n![Main Menu](http://localhost:9978/imgs/MainMenu.png)\n\nBy clicking on the hamburger icon on the lower far left corner, you \nwill open the main menu shown above. This give you access to the\nscript editor, the regular expressions editor, template editor, and the \ncommand console. You can also access the installers for\n**Alfred**, **Keyboard Maestro**, **Dropzone 3**, **PopClip**, and\n**LaunchBar**. These scripts allows you to copy files or text to\nspecified notepads. It also allows you to execute scripts on text\nsent to it as well. There is a [fman](https://fman.io) plugin for\nworking with ScriptPad.\n\nYou can also change the preferences from the main menu by selecting\n`Preferences`. The preference page will describe everything you can\nchange there.\n\nThe last option, `Quit`, will exit out of the ScriptPad program. If\nthe program isn't running, the scripts for the **Alfred**, **fman**,\n**Keyboard Maestro**, **Dropzone 3**, **PopClip**, and **LaunchBar**\nwill not function as well.\n\n![About Dialog](http://localhost:9978/imgs/About.png)\n\nIf you select `About` in the main menu, you will see the above about\ndialog. This dialog tells about who created the program and the third\nparty tools used. This program is created with\n**[Svelte v3](https://svelte.dev)**,\n**[Mask](https://github.com/jakedeichert/mask)**, and\n**[NW.js](https://nwjs.io/)**.\n\nFrom this main menu, you can open the \n[Command Console](http://localhost:9978/CommandConsole) which gives access \nto [Node-Red](/#/NodeRed) console. From there you can \nrun different scripting commands and actions.\n\nThe `Close` button will close the dialog. Openning any other dialog\nwill also close this dialog.\n\n","# Scripts\n\nThe scripts section of ScriptPad comes in two areas: running scripts from the \nmenu and creating/editing the scripts in the script editor.\n\n![Scripts Menu](http://localhost:9978/imgs/ScriptsMenu.png)\n\nWhen you are in a note area, press `<ctrl>+m` to toggle the scripts menu as seen\nabove. Your scripts are the brighter blue and the system scripts are the paler\nblue (assuming your still using the default theme). This menu will always show\nyour scripts first.\n\nAs you type in the scripts menu, the choices will narrow down according to what \nyou type. This is to help you navigate the large number of scripts. You can use\nthe up and down arrow keys to move the highlight. Pressing `<enter>` will action\nthe script.\n\nIf you had text selected in the note, that text will be passed to the script.\nOtherwise, the whole note will be passed to the script. Whatever the script\nreturns, will replace the text sent to it.\n\n## Script Editor\n\n![Script Editor](http://localhost:9978/imgs/ScriptEditor.png)\n\nBy pressing `<ctrl>+e`, you can open the script editor window shown above.  The\nscript editor is used to create/edit user script to use on the notepads using\nthe `<ctrl>+m` script menu. These scripts can process the text given in the\ncurrent notepad, add new information to the current notepad, or totally over\nwrite it. It's up to you what you want your script to do.\n\nThe first input takes the name of the script. If you give a new script the same\nname as one that already exists, you will over write it. It will not let you name\na user script the same as a system script.\n\nThe check box after the script name tells NotePad to insert the returned\ninformation if checked. If not checked, it will replace the selected text or all\nthe text in the notepad if no text was selected.\n\nThe variable `SP.text` contains either all the text in the note if there wasn't\na selection, or just the selected text. You read this variable to get the text to\nprocess and write into the variable what you want to replace either the selection\nor all the text in the notepad.\n\nThere are some predefined libraries in variables for your scripts to use. You\ncan make use of the following:\n\n|  |  |\n| -- | ---- |\n| SP.jQuery | [jQuery library](https://jquery.com) |\n| SP.mathjs | [Math.js library](http://mathjs.org/) |\n| SP.moment | [moment.js library](https://momentjs.com) |\n| SP.Handlebars | [Handlebars library](https://handlebarsjs.com/) |\n\nThe are some predefined function available as well:\n\n|  |  |\n| -- | ---- |\n| SP.insertCharacters(`<num>`,`<char>`) | This function makes a string of `<num>` `<char>`. |\n| SP.returnNote(`<id>`) | This function returns the note with the `<id>`. |\n| SP.runScript(`<scrpt>`,`<text>`) | This function runs the `<scrpt>` as a string on the `<text>` text. |\n\nYou can create script in one note and use a different note for the input. \nFor example, in a note, place the following code:\n\n```js\n\ntry {\n  var lines = SP.text.split('\\n');\n  SP.text = '';\n  for(var i = 0; i < lines.length ; i++) {\n      var match = lines[i].trim().match(/^\\d+\\. (.*)$/);\n    if (match != null)\n        SP.text += match[1] + '\\n';\n  }\n} catch (e) {\n   SP.text += \"\\n\\n\" + e.toString()\n}\n\n```\n\nThen go to a different note and place several lines of text. Run the\nscript `Bullet lines with Numbers`. Every line will have the proper number at\nthe front of it. Now, run the script `Evaluate Note # as Script` with `#` the\nnumber of the note where you put the script. The numbers at the beginning will now be\nremoved! You can use the script editor to save this script and use it from the\nscript menu.\n\n### Predefined Math Scripts\n\nNotePad has scripts for processing math: the 'Basic Math' and 'Evaluate Page for\nMath' scripts. The 'Basic Math' script is for processing arbitrary pieces of math\nin a selection. The 'Evaluate Page for Math' script is for processing the entire\nnote with a nice running result along the right. The 'Basic Math' script doesn't\nreset the state of the math library (ie: variable definitions and functions),\nbut the 'Evaluate Page for Math' does each time invoked so as to not create\nmultiple copies of function and variables.\n\nCopy the following note to a notepad:\n\n```md\n\n# Using the ‘Evaluate Page for Math’ script\n\nYour notes can have any text you need. But when a line starts with a ‘>’, t\nhat whole line is processed for math. The line is processed and the answer pushed\nto the right with a ‘|’ symbol.\n\n> 6 * 95\n> x=6*8-10\n> x\n\nText in the middle doesn’t clear out the variable or function assignments before it.\n\n> f(x)=x^2-5*x+12\n> f(60)\n> f(x)\n\nThe length of the note isn’t a concern either.\n\n> f(100)\n\n> bank=34675\n> check=5067\n> balance = bank - check\n\n> sin(45)\n\nThe math package used doesn’t do conversions or symbols inside of the mat\nh expressions. The math library used is [mathjs 4.0](http://mathjs.org/).\n\n```\n\nThen press `<ctrl>-m` and select the 'Evaluate Page for Math' script. Each\nline with the '>' as the front character now has the results to the right.\nWhen you change the text lines and re-run the script, the math lines are all \nupdated. All other lines are not effected by the script. You can change any\nequation or variable and it's effects will trickle down the page.\n\n","# Regular Expression Editor\n\n![Regular Expression Editor](http://localhost:9978/imgs/RegExpEditor.png)\n\nThe Regular Expression editor will show you the results of your regular \nexpressions, and color code the sub-matches (embedded sub-matches are not\nsupported). You can save your regular expressions and recall them by name\ngiven. You invoke the regular expression editor with `<ctrl>-r`. You can list\nthe defined regular expressions with `<ctrl>-m`. The editor will allow you to\nsave the regular expressions with the `Save` button and perform all the\nsubstitutions with the `Change All` button. You can also extract the selected\nentries using the `Extract` button. Pressing `<ctrl>-r`, `Extract` button, or the\n`Change All` button will close the regular expressions editor. \n\n","# Features Still Coming\n\nSince I use this application everyday, I'm constantly thinking of new things I would like to add. If you have any new ideas, just let me know and I'll see what I can do.\n\nCurrently, these are things that I'm either working on or plan to do:\n\n- Script launching webpage for using tablets/phones as a launch control center.\n- Command line console with similar features to Xiki.\n   - A way to run scripts on files.\n   - Tracks the disk location.\n   - Make it similar to what Xiki could have been.\t - Use [xterm: Console terminal in the browser](https://xtermjs.org/)\n- Running a script from inside of a script isn't working.\n- Add the ability for running external scripts.\n- Add scripts from GitHub that are marked for Scriptpad.\n- Create a library to use for controling other windows. \n- Get it working on Linux and Windows.\n- Create modules for:\n  - the BitBar and Infinity Desktop work-a-like.\n  - An icon on the desktop side that expands to a directory view.\n\n","# Files Used By NotePad\n\nAll notes, scripts, and preferences are stored in the home directory called \n`~/.scriptpad/`. The notes are in the file `.notesjson`. All user defined\nscripts are kept in the file `.scriptsjson`. All user defined regular expressions\nare stored in the `.regexpjson` file. The preferences are in the `preferences.json`\nfile while all the styles are in the `styles` directory. The preferences for the\nBulliten Board program are in the file `bullitenBoard.json`. The `templates.json` \nfile contains all of the user defined templates. The `dialogs` directory contains \nthe user defined dialogs.\n\n","# Todo List\n\n![Todo List](http://localhost:9978/imgs/TodoList.png)\n\nThe todo list is currently populated from your **[NotePlan](www.noteplanapp.com)**\ntodo for the current day and any **[TaskPaper](https://www.taskpaper.com/)** formated files you add to it in \nthe preferences. You can add new todos by typing in the input box on top\nand press enter. You can mark a todo as done by clicking on the empty box. You\ncan remove a todo from the display by clicking the `x` to the right of the todo\nitem. Deleting the item doesn't actually delete it, but marks it as done and\nremoves it from being displayed.\n","# Preferences\n\n![Preferences - General](http://localhost:9978/imgs/Preferences-General.png)\n\nWhen you press the `Preferences` link in the main menu, this dialog will open. \nOn the `General` tab, you can change the code wrap and editor keyboard mappings\nfor the different editors.\n\nThe bottom of all of the Preferences screens show a `Save Styles & Preferences`\nand a `Quit Preferences` button. The first will save the preferences to the hard\ndrive while the other will leave the preferences dialog all together.\n\n![Preferences - Theme](http://localhost:9978/imgs/Preferences-Theme.png)\n\nWhen you click the `Theme` tab, you will get this screen. Here, you can change\nthe theme of **ScriptPad** or create your own. Setting the `Name of theme` to\n`New` will allow you to add a new name for a theme. The changes will be saved\ninto that theme name.\n\n![Color Picker](http://localhost:9978/imgs/Preferences-ColorPicker.png)\n\nClicking on a colored circle will show a color picker dialog to pick a new color.\nSelect a color and press the `Select` button to set the new color. The `Quit`\nbutton will exit the color picker without setting a new color. You can also enter\nan RGB hex value for the color in the input dialog.\n\n![Preferences - Todo](http://localhost:9978/imgs/Preferences-Todo.png)\n\nWhen you click the `Todo` tab, you will be able to enable/disable the **NotePlan**\ntodo list and the **TaskPaper** todo lists. **NotePlan** will just show the current \ndays todo items, while the **TaskPaper** todo list can be as many files as you want. \nYou specify the location of the file and the name you want to associate with it.\n\n\n","# Templater\n\nScriptPad comes with a full template system built with Handlebars. It is accessed in \nthe notes with `<ctrl>+p`. The menu will prompt for which template to insert into\nthe note. User defined templates are in a lighter blue than the system templates \n(assuming you are using the default theme).\n\n![Template Selection Menu](http://localhost:9978/imgs/TemplaterMenu.jpg)\n\nWhen you start typing, the menu will shorten the list based on the closest match\nto what you type. When you select a template, it is expanded in the note at the\nlocation of the cursor. This is added to the note and will not destroy text\nalready there.\n\nPressing `<ctrl>+p` again without selecting a template will will close the\ntemplate menu.\n\n## Template Editor\n\n![Template Editor](http://localhost:9978/imgs/TemplateEditor.jpg)\n\nPressing `<ctrl>+t` will open the template editor shown above. You have to give it\na name, description, and the actual template. \n\n## Template Syntax\n\nThe templating engine used is call [Handlebars](https://handlebarsjs.com/). It is \nused in the templates and in the dialog boxes for the BulletinBoard. Handlebars \nallows you to have a text file with anything in it along with some macros. Some \nmacros need auguments and some do not. The macros are expanded and placed into the \ntext. Macros with arguments are called helpers. Along with \nthe standard Handlebar helpers, several others have been added as well. The \nfollowing is an explanation of the additional helpers:\n\n| | |\n|--|----|\n| `{{save <name> <text>}}` | This command creates a helper named `<name>` with the expanding text of `<text>`. It also places the given `<text>` at the point of definition. This allows you to create text snippets on the fly inside the template. Very handy. |\n| `{{clipboard}}` | This helper command places the current clipboard contents at the point in the template. |\n| `{{date <format>}}` | This will format the current date and time as per the format string given. See the help document that is loaded upon initialization. |\n| `{{cdate <date/time> <format>}}` | This takes the date/time string and formats it according to the format given. See the help document that is loaded upon initialization. |\n| `{{env <name>}}` | This will place the environment variable that matches `<name>` at that location |\n| `{{last <weeks> <dow> <format>}}` | This will print the date `<weeks>` ago in the `<format>` format for the `<dow>` day of week. |\n| `{{next <weeks> <dow> <format>}}` | This will print the date `<weeks>` in the future using the `<format>` format for the `<dow>` day of week. |\n| `{{userfillin <question> <default>}}` | This will prompt the user with `<question>` and put the `<default>` as a quick answer. The response will be put into the template. |\n| `{{copyclip <clipname>}}` | This will put the Alfred Copy Clip workflow's `<clipname>` into the template. |\n\nThe following data expansions are defined as well:\n\n`{{cDateMDY}}` gives the current date in Month Day, 4-digit year format\n\n`{{cDateDMY}}` gives the current date in Day Month 4-digit Year format\n\n`{{cDateDOWDMY}}` gives the current date in Day of Week, Day Month 4-digit year format\n\n`{{cDateDOWMDY}}` gives the current date in Day of Week Month Day, 4-digit year format\n\n`{{cDay}}` gives the current date in Day format\n\n`{{cMonth}}` gives the current date in Month format\n\n`{{cYear}}` gives the current date in 4-digit year format\n\n`{{cMonthShort}}` gives the current date in Short Month name format\n\n`{{cYearShort}}` gives the current date in 2-digit year format\n\n`{{cDOW}}` gives the current date in Day of Week format\n\n`{{cMDthYShort}}` gives the current date in Month day 2-digit year format\n\n`{{cMDthY}}` gives the current date in Month Day 4-digit year format\n\n`{{cHMSampm}}` gives the current date in h:mm:ss a format\n\n`{{cHMampm}}` gives the current date in h:mm a format\n\n`{{cHMS24}}` gives the current date in H:mm:ss 24 hour format\n\n`{{cHM24}}` gives the current date in H:mm 24 hour format\n\n","# Alfred Workflow\n\nOnce you install the Alfred ScriptPad Workflow, you will be able to interact with\nScriptPad through Alfred. Most notably, you'll be able to action scripts and templates\nright from Alfred.\n\n| | |\n| --- | --------- |\n| sp:run | This will accept text on the command line. When the user presses `<enter>` on the commmand line, they will be prompted for the script to run on it. The user can type part of the name to narrow down the list of possible scripts. When a script is selected, the script is ran with the text given and te results are placed in the topmost application and in the clipboard. |\n| sp:template | This will accept text on the command line. When the user presses `<enter>` on the commmand line, they will be prompted for the template to run. The user can type part of the name to narrow down the list of possible templates. When a template is selected, the template is ran with the text given and te results are placed in the topmost application and in the clipboard. |\n| bboard | This will accept text on the command line. When the user presses `<enter>` on the command line, the text will be sent to the BulletinBoard module for displaying. If the text is `-`, then the message in the BulletinBoard will be errased and the board hiden. |\n| bbappend | This will accept text on the command line. When the user presses `<enter>` on the command line, the text will be appended to the text in the BulletinBoard. |\n| note | This willl accpet text on the command line. When the user presses `<enter>` on the command line, they will be asked for a note number and whether to overwrite or append the text. Depending on what the user selects will be done to the note. |\n| getnote | This will ask for which note. The note will then be pasted into the topmost application and in the clipboard. |\n| bb:dialog | This will ask for which dialog to display. You can type to narrow down the list. It will then ask for a list of parameters surrounded in quotation marks. That will be passed to the dialog program to display the requested dialog. The result are returned and put into the clipboard. |\n\nThis workflow is expanded as the ScriptPad program gets more features. Many of these can be trigged by hotkeys as well. Please\nrefer to the workflow to set the hotkeys yourself.\n\n","# Dropzone Action\n\nWhen you install the Dropzone actions, you can put text into a ScriptPad note or \nrun scripts on files or text dropped on the action. \n\n![Script Pad Action Configuration](http://localhost:9978/imgs/DropzoneScriptPadAction.jpg)\n\nThe `Script Pad` action will allow you to set it up by clicking on it. When you \nclick on it, it gives you the option to which note to save text to (default is note \n#3) and whether to append it or overwrite it (the default is append). If you \ndrop text files or copied text to the action, it will be applied to the note \nsetup in the configuration when you click on it.\n\n![Run Script Action Configuration](http://localhost:9978/imgs/DropzoneRunScript.jpg)\n\nThe `Run Script` action allows you to pick a script to apply to dropped text or \nfiles. When you click on the action, it will show the above dialog asking\nfor the script to use. If you drop text, the script is ran on the text and \ncopied back to the clipboard. If you drop a file, the file is changed according \nto the script.\n","# Keyboard Maestro\n\nWhen you install the Keyboard Maestro macros, you will have macros to save, append, and\nget text from each of the notes. There is also two keyboard expander macros for\npasting from a note and pasting a template into the current document.\n\nBy copying text to the clipboard and then pressing `<ctrl><shift>;`, a menu will \nappear for which note to use. Just press a number key or select\none of the entries with the mouse. The clipboard text will then be added to the\nbottom of that note.\n\nBy copying text to the clipboard and then pressing `<ctrl><shift>'`, a menu will \nappear for which note to use. Just press a number key or select\none of the entries with the mouse. The clipboard text will then overwrite the\ntext of that note.\n\nBy typing `;/`, a template name, and `/tp`, then the named template will be pasted \ninto the application. For example, by typing `;/Today/tp` the template named `Today` \nwill be pasted into the application you are typing.\n\nBy typing `;/`, a note number, and `/np`, then the corresponding note will be pasted \nin it's place. For example, by typing `;/2/np` in a wordprocessor, the contents of \nnote #2 will be place in it's place.\n\n","# LaunchBar Actions\n\nOnce you install the LaunchBar ScriptPad action, you will be able to interact with\nScriptPad through LaunchBar. Most notably, you'll be able to action scripts and templates\nright from LaunchBar.\n\n| | |\n| --- | --------- |\n| ScriptPad - Run Script | This will accept text on the command line. When the user presses `<enter>` on the commmand line, they will be prompted for the script to run on it. The user can type part of the name to narrow down the list of possible scripts. When a script is selected, the script is ran with the text given and te results are placed in the topmost application and in the clipboard. |\n| ScriptPad - Run Template | This will accept text on the command line. When the user presses `<enter>` on the commmand line, they will be prompted for the template to run. The user can type part of the name to narrow down the list of possible templates. When a template is selected, the template is ran with the text given and te results are placed in the topmost application and in the clipboard. |\n| ScriptPad - Set BulletinBoard | This will accept text on the command line. When the user presses `<enter>` on the command line, the text will be sent to the BulletinBoard module for displaying. If the text is `-`, then the message in the BulletinBoard will be errased and the board hiden. |\n| ScriptPad - Append BulletinBoard | This will accept text on the command line. When the user presses `<enter>` on the command line, the text will be appended to the text in the BulletinBoard. |\n| ScriptPad - Set Note | This willl accpet text on the command line. When the user presses `<enter>` on the command line, they will be asked for a note number and whether to overwrite or append the text. Depending on what the user selects will be done to the note. |\n| ScriptPad - Paste Note | This will ask for which note. The note will then be pasted into the topmost application and in the clipboard. |\n| ScriptPad - Dialog | This will ask for which dialog to display. You can type to narrow down the list. It will then ask for a list of parameters surrounded in quotation marks. That will be passed to the dialog program to display the requested dialog. The result are returned and put into the clipboard. |\n\nThis workflow is expanded as the ScriptPad program gets more features. \n\n","# PopClip Extension\n\nWhen you install the PopClip extension, it will allow you to select text and \noverwrite or append it to a note. By editing the configuration for the extension, \nyou can change which note and what type of operation to perform.\n\n![PopClip Extension Configuration](http://localhost:9978/imgs/PopclipConfig.jpg)\n\nWhen you edit the configuration in PopClip, you will see the above dialog. Here, \nsimply put in the note number and operation type (overwrite or append). When you \nselect text and select the extension in PopClip, that action will be performed.\n\n\n","# queryUser Program\n\nThis program is used to enteract with the BulletinBoard module. You use the\n`queryUser` command line with the following parameters:\n\n```zsh\nqueryUser <dialog> <data1>.....<datan>\n```\n\nWhere dialog is the name of the dialog to be displayed. The data1...datan are quoted \ndata fields used to populate the `{{data1}}` to `{{datan}}` template macros.\n\nTo get a json list of all dialogs defined, both system dialogs and user defined dialogs, \njust run this command:\n\n```zsh\nqueryUser list\n```\n\nYou will need to put the queryUser command line program on your path to be able to\nuse it. It's locations are:\n\n| OS | Directory Structure |\n| --- | -------- |\n| macOS | `/Application/ScriptPad/contents/Resources/bin` |\n| Linux | coming soon |\n| Windows | coming soon |\n\n### Creating Dialogs\n\nThe dialogs used are easy to create. In the `~/.scriptpad/dialogs` directory, create\na file with the name of your dialog with an extension of `.json`. To create a dialog\ncalled question, you would create the file `querstion.json`.\n\nThe structure for the file is:\n\n```json\n{\n  \"html\": \"\", \n  \"width\": 200, \n  \"height\": 80, \n  \"x\": 400, \n  \"y\": 200\n}\n```\n\nThe `html` element will be the html needed to create the dialog and action the\nbuttons in the dialog. The `width` and `height` items define the minimum width\nand height of the dialog. The `x` and `y` items define the location of the upper\nleft corner of the dialog.\n\nThe dialog will be displayed below the message field, if there is a message.\n\nFor example, this is the file for the `question.json` dialog:\n\n```json\n{\n  \"html\": \"<label>{{data1}}</label>\n  <input id='name' type='text' value='{{data2}}' autofocus ></input>\n  <button type='button' onclick='globalThis.sendBack()'>Okay</button>\n  <style>\n    button {\n      margin: 10px auto 10px auto;\n      background-color: gray;\n    }\n\n    #dialog {\n      width: 400px;\n      height: 80px;\n      align-content: center;\n      align-items: center;\n      text-align: center;\n    }\n  </style>\n  <script>\n    globalThis.sendBack = function() {\n      globalThis.BBData.dialogStore.dialogResult = document.getElementById('name').value; \n      globalThis.BBData.dialogStore.callBack();\n    }\n  </script>\", \n  \"width\": 400, \n  \"height\": 80, \n  \"x\": 400, \n  \"y\": 200\n}\n```\n\nBefore processing each dialog file, the carrage returns are removed. Therefore, you \ncan define the html on multiple lines. This helps to create dialogs that are easy\nto read.\n\nThe `#dialog` is the HTML element id for the div element that the dialog HTML is \nplaced. Therefore, you can customize the element by referring to `#dialog`.\n\nTo send information back, you just fill the `globalThis.sendback` variable with a\nfunction that will get the information in the dialog, store it in the \n`globalThis.BBData.dialogStore.dialogResult` variable. You then call the \n`globalThis.BBData.dialogStore.callBack()` function to send the information back\nto the queryUser program. You setup the button to call the `globalThis.sendback()` \nfunction on click event.\n\nThis program can be called in scripts or from ScriptPad itself in order to get information\nfrom the user. \n","# Modules\n\nThe ScriptPad program has the ability to launch modules. There are \nboth built-in modules and user defined modules.\n\nThe built-in modules are a part of the **ScripPad** program. I'll be\nadding new ones in the future, so keep checking for updates.\nCurrently, the builtin-modules are:\n\n- BulletinBoard\n- Remote Control\n\n### BulletinBoard\n\nThis module launches a window with a tcp server. It starts off invisible.\nYou can cause the window to appear and display text you send to it over\ntcp. For example, in Ruby, run this script:\n\n```ruby\nrequire 'net/http'\nrequire 'json'\n\ndef uri_encode(str)\n  str.gsub(URI::UNSAFE) do |match|\n    match.each_byte.map { |c| sprintf('%%%02X', c.ord) }.join\n  end\nend\nif ARGV[0] == '-' then\n  message = ''\nelse\n  message = uri_encode(ARGV[0])\nend\n\nuri = URI(\"http://localhost:9697/api/message/#{message}\")\nhttp = Net::HTTP.new(uri.host, uri.port)\nreq = Net::HTTP::Get.new(uri.path, 'Content-Type' => 'application/json')\nreq.body = {msg: \"#{message}\"}.to_json\nres = http.request(req)\nputs \"response #{res.body}\"\n```\n\nThis script will send the text on the command line to the BulletinBoard module \nand will be displayed above other windows. It's default location is the upper \nleft corner. To clear the message and have the window close, send '-' as the\ntext. By changing the address to send the text from:\n\n```ruby\nuri = URI(\"http://localhost:9697/api/message/#{message}\")\n```\n\nto\n\n```ruby\nuri = URI(\"http://localhost:9697/api/message/append/#{message}\")\n```\n\nIt will append to the already existing text. I use this functionality the most for\ndisplaying contents of a file that gets changed by automated processing.\n\nThe BulletinBoard also allows you to create and display dialogs that will return\ninformation to the calling program. The `queryUser` command line program will \nshow a dialog and return it's results when the user finishes with it. Using and \nmaking more dialogs is covered in the `queryUser Program` help section.\n\n### Remote Control\n\nThe Remote Control module allows the user to load a page on any other computer on \nsame subnet. This web page will display buttons that will execute scripts from \nScriptPad. You can control the buttons and assign any script you want to use. This \nmodule is still under development.\n\n","# Command Console\n\nFrom the main menu, you can open the Command Console.\n\n![The Command Console](http://localhost:9978/imgs/CommandConsole.png)\n\nThis console gives nine different consoles to run scripts on files. It also \ngives access to the [NodeRed](/#/NodeRed) by the right most red button.\n\nWhen this is functional, it will give the user the ability to have nine \nterminals to different locations and able to run the scripts in ScriptPad on \nany file. It will also have a plugin API system for adding new commands. Eventually, \nnew commands and scripts will be downloadable from GitHub.\n\n\n","# NodeRed\n\nThe right most red button on the Command Console is for opening the [NodeRed](https://nodered.org/) \nconsole.\n\n![NodeRed Console](http://localhost:9978/imgs/NodeRed.png)\n\nThe [NodeRed](https://nodered.org/) console gives \naccess to the NodeRed scripting engine. With it, you can setup automated \nprocesses to access things on the Internet, automate home electronics, or about \nanything that you can imagine. The ScriptPad runs a NodeRed server in the background \nall the time. I currently have around 20 flows running on it and I see no issues \nwith it taking too much processor attention. It isn't a resource hog at all!\n\nThere are currently three custom nodes for ScriptPad in Node-Red when launched \nin this manner. The new nodes are:\n\n| Node Name | Description |\n| --- | -------- |\n| spscripts | This node allows you to specify any script in ScriptPad. The node will take what comes in the `msg.payload`, run the script on it, and return a new `msg.payload` with the results of the script. |\n| spvariables | This node will take what comes into the node from `msg.payload` and save it into the variable named in the node. ScriptPad makes the variable available to scripts and by a REST API. If a client is listening to the websocket of the variable name, they will get the message of it's change. A client can also connect to the websocket name `variablechange` to get a message on any variable change. |\n| splogger | This node allows the user to take any `msg.payload` that comes to it and display it in the Node-Red terminal in ScriptPad. This is great for debugging. |\n\nAt the bottom of the Node-Red console are two buttons: Edit Flows and Stop. The `Stop` \nbutton will stop the Node-Red server and the button will change to `Start`. To edit \nyour flows, press the `Edit Flow` button.\n\n![Edit Flows Window](http://localhost:9978/imgs/FlowEditor.png)\n\nThis is where you can create and edit your Node-Red flows. Please refer to the \n[Node-Red website](https://nodered.org/) for more information.\n\nIf you have configured the Node-Red dashboard and turned it on in the preferences, \nthen you will have a `Dashboard` button as well. When you press the `Dashboard` \nbutton, it will open the dashboard in a separate window. Please read and follow the \nNode-Red documentation on how to use the Node-Red dashboard.\n\n","# Web API\n\nScriptPad has a large web based API for interfacing with other applications, \ncommand line tools, or whatever else would help. The base address for the \nAPIs is `http://localhost:9978/api`. Every endpoint in this table builds \non this base.\n\n| Endpoint | Description |\n| --- | ------ |\n| /web/launch | This is a PUT method access with the body containing a JSON structure with one element 'url'. That should contain the URL to open a browser window. This is using the internall browser. |\n| /note/<number>/(a or w) | A PUT request will assert the note value while the GET request will return the note. Both use a JSON structure with the element `note`. The `a` on the end will append to the note while a `w` will over write. |\n| /script/list | A GET request will return a list of scripts that can be ran on ScriptPad. |\n| /script/run | A PUT request requires a JSON body with a `script` element and a `text` element. The `script` script will be ran with the `text` and returned in a JSON structure with a `text` element. |\n| /template/list | A GET request will return the name of all the templates in ScriptPad. |\n| /template/run | A PUT request requires a JSON body with a 'template' element and a 'text' element. The `template` will be ran with the `text` as an input. The results are return in a JSON structure with the result in the 'text' element. |\n| /getip | A GET request will return the IP of the computer that is running ScriptPad. |\n| /nodered/var/<name> | A GET request will return the current value of the Node-Red variable. A PUT request will set the Node-Red variable to the `text` element of the JSON structure in the body. |\n\nIf you create a script on your path with this content:\n\n```sh\n#!/bin/sh\n\n/usr/local/bin/wget --body-data=\"{ \\\"url\\\": \\\"$1\\\" }\" --header='Content-Type:application/json' 'http://localhost:9978/api/web/launch' --method=PUT -O /dev/null 3>/dev/null 2>/dev/null 1>/dev/null\n```\n\nit will open the URL given to it in the browser window of ScriptPad. You will have to have `wget` installed on your system. \nI've named it `openURL` and use it to open sites on the command line with `openURL \"http://customct.com\"`. That will open my \nweb site.\n\nAll the other endpoints are used to make the plugins for Alfred, Keyboard Maestro, Dropzone, PopClip, and Launchpad.\n\n","<script>\n  import Main from './Main.svexy'\n  import MainWindows from './MainWindows.svexy'\n  import MainMenu from './MainMenu.svexy'\n  import ScriptEditor from './ScriptEditor.svexy'\n  import RegularExpressionEditor from './RegularExpressionEditor.svexy'\n  import FeaturesStillComming from './FeaturesStillComming.svexy'\n  import FilesUsed from './FilesUsed.svexy'\n  import TodoList from './TodoList.svexy'\n  import Preferences from './Preferences.svexy'\n  import Templater from './Templater.svexy'\n  import Alfred from './Alfred.svexy'\n  import Dropzone from './Dropzone.svexy'\n  import KeyboardMaestro from './KeyboardMaestro.svexy'\n  import LaunchBar from './LaunchBar.svexy'\n  import PopClip from './PopClip.svexy'\n  import QueryUser from './QueryUser.svexy'\n  import Modules from './Modules.svexy'\n  import CommandConsole from './CommandConsole.svexy'\n  import NodeRed from './NodeRed.svexy'\n  import API from './API.svexy';\n  \n  let currentPage = 'Main'\n\n  function changePage(page) {\n    currentPage = page;\n  }\n</script>\n\n<style>\n\n  #page {\n    display: flex;\n    flex-direction: row;\n    overflow: hidden;\n  }\n\n  #main {\n    display: block;\n    width: 65%;\n    margin-right: 20px;\n    overflow-y: scroll;\n  }\n\n  #sidebar {\n    display: flex;\n    flex-direction: column;\n    width: 25%;\n    margin-left: 20px;\n  }\n\n  #sidebar ul li {\n    cursor: pointer;\n    margin: 10px 0px 0px 0px;\n    color: blue;\n  }\n\n  :global(img) {\n    border-radius: 10px;\n    border: 2px solid black;\n  }\n\n  :global(td) {\n    padding: 5px;\n    border: 2px solid black;\n  }\n</style>\n\n<div id=\"page\">\n  <div id=\"sidebar\">\n    <h2>Contents</h2>\n    <ul>\n      <li on:click=\"{() =>{ changePage('Main')}}\">ScriptPad</li>\n      <li on:click=\"{() =>{ changePage('MainWindow')}}\">Main Window</li>\n      <li on:click=\"{() =>{ changePage('MainMenu')}}\">Main Menu</li>\n      <li on:click=\"{() =>{ changePage('ScriptEditor')}}\">Script Editor</li>\n      <li on:click=\"{() =>{ changePage('RegularExpressionEditor')}}\">Regular Expression Editor</li>\n      <li on:click=\"{() =>{ changePage('TodoList')}}\">Todo lists</li>\n      <li on:click=\"{() =>{ changePage('Templater')}}\">Templater</li>      \n      <li on:click=\"{() =>{ changePage('Preferences')}}\">Preferences</li>\n      <li on:click=\"{() =>{ changePage('CommandConsole')}}\">Command Console</li>\n      <li on:click=\"{() =>{ changePage('NodeRed')}}\">Node-Red</li>\n      <li on:click=\"{() =>{ changePage('Modules')}}\">Modules</li>\n      <li on:click=\"{() =>{ changePage('queryUser')}}\">queryUser Program</li>\n      <li on:click=\"{() =>{ changePage('API')}}\">API Reference</li>\n      <li on:click=\"{() =>{ changePage('Alfred')}}\">Alfred Workflow</li>\n      <li on:click=\"{() =>{ changePage('Dropzone')}}\">Dropzone Action</li>\n      <li on:click=\"{() =>{ changePage('KeyboardMaestro')}}\">Keyboard Maestro</li>\n      <li on:click=\"{() =>{ changePage('LaunchBar')}}\">LaunchBar Actions</li>\n      <li on:click=\"{() =>{ changePage('PopClip')}}\">PopClip Extension</li>\n      <li on:click=\"{() =>{ changePage('FilesUsed')}}\">Files Used</li>\n      <li on:click=\"{() =>{ changePage('FeaturesStillComming')}}\">Features Still to Come</li>\n    </ul>\n  </div>\n  <div id=\"main\" >\n    {#if currentPage === 'Main'}\n      <Main />\n    {:else if currentPage === 'MainWindow'}\n      <MainWindows />\n    {:else if currentPage === 'MainMenu'}\n      <MainMenu />\n    {:else if currentPage === 'ScriptEditor'}\n      <ScriptEditor />\n    {:else if currentPage === 'RegularExpressionEditor'}\n      <RegularExpressionEditor />\n    {:else if currentPage === 'TodoList'}\n      <TodoList />\n    {:else if currentPage === 'FilesUsed'}\n      <FilesUsed />\n    {:else if currentPage === 'Templater'}\n      <Templater />\n    {:else if currentPage === 'Preferences'}\n      <Preferences />\n    {:else if currentPage === 'CommandConsole'}\n      <CommandConsole />\n    {:else if currentPage === 'NodeRed'}\n      <NodeRed />\n    {:else if currentPage === 'API'}\n      <API />\n    {:else if currentPage === 'Alfred'}\n      <Alfred />\n    {:else if currentPage === 'Dropzone'}\n      <Dropzone />\n    {:else if currentPage === 'KeyboardMaestro'}\n      <KeyboardMaestro />\n    {:else if currentPage === 'LaunchBar'}\n      <LaunchBar />\n    {:else if currentPage === 'PopClip'}\n      <PopClip />\n    {:else if currentPage === 'FeaturesStillComming'}\n      <FeaturesStillComming />\n    {:else if currentPage === 'queryUser'}\n      <QueryUser />\n    {:else if currentPage === 'Modules'}\n      <Modules />\n    {/if}\n  </div>\n</div>\n","import Documentation from './Documentation.svelte';\n\nconst app = new Documentation({\n\ttarget: document.body,\n\tprops: {\n\t}\n});\n\nexport default app;\n\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","current_component","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","seen_callbacks","Set","flushidx","flush","saved_component","length","update","$$","pop","i","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","transition_in","block","local","delete","transition_out","o","c","d","create_component","mount_component","customElement","on_mount","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","type","index","indexOf","splice","$set","$$props","obj","$$set","keys","numScripts","numMods","h1","p0","strong0","p1","p2","p3","p4","p5","p6","p7","p8","h2","p9","p10","table0","p11","table1","p12","pre0","p13","h3","p14","p15","pre1","p16","ul2","h20","h21","table","p17","p18","p19","p20","p21","p22","p23","pre2","pre3","ul","h30","h31","pre","div2","div0","li0","li1","li2","li3","li4","li5","li6","li7","li8","li9","li10","li11","li12","li13","li14","li15","li16","li17","li18","li19","div1","r","currentPage","changePage","page","$$invalidate","body"],"mappings":"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"}